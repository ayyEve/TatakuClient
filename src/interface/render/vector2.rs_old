use std::{ops::{Add, Div, Mul, Neg, Sub, Rem, AddAssign, SubAssign, MulAssign, DivAssign, RemAssign}, fmt::Display};

#[derive(Copy, Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature="serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Vector2 {
    pub x: f64,
    pub y: f64,
}

#[allow(dead_code)]
impl Vector2 {
    pub const fn new(x:f64, y: f64) -> Self { Self {x, y} }
    pub const fn zero() -> Self { Self::ZERO }
    pub const fn one() -> Self { Self::ONE }

    pub const ZERO:Self = Self { x:0.0, y:0.0 };
    pub const ONE:Self = Self { x:1.0, y:1.0 };
    
    pub const fn with_x(x:f64) -> Self { Self {x, y: 0.0} }
    pub const fn with_y(y:f64) -> Self { Self {x: 0.0, y} }

    
    pub fn atan2(self) -> f64 {
        (-self.y).atan2(self.x)
    }
    pub fn atan2_wrong(self) -> f64 {
        self.y.atan2(self.x)
    }

    pub fn from_angle(a:f64) -> Self {
        Self::new(a.cos(), a.sin())
    }
    
    pub fn length(self) -> f64 {
        self.length_squared().sqrt()
    }
    pub fn length_squared(self) -> f64 {
        self.x * self.x + self.y * self.y
    }

    pub fn normalize(self) -> Self {
        let magnitude = self.length();
        if magnitude == 0.0 { self }
        else { self / magnitude }
    }

    pub fn distance(&self, p2: Self) -> f64 {
        self.distance_squared(p2).sqrt()
    }
    pub fn distance_squared(&self, p2: Self) -> f64 {
        (self.x - p2.x).powi(2) + (self.y - p2.y).powi(2)
    }
    pub fn direction(&self, v2: Self) -> f64 {
        let direction = v2 - *self;
        (direction.x / direction.length()).acos()
    }

    // get only this vector's x value
    pub fn x_portion(mut self) -> Self {
        self.y = 0.0;
        self
    }
    // get only this vector's y value
    pub fn y_portion(mut self) -> Self {
        self.x = 0.0;
        self
    }

    pub fn cross(self, other: Self) -> f64 {
        self.x * other.y - self.y * other.x
    }
    pub fn dot(self, other: Self) -> f64 {
        self.x * other.x + self.y * other.y
    }
}


impl Display for Vector2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ x:{}, y:{} }}", self.x, self.y)
    }
}


// negative nancy
impl Neg for Vector2 {
    type Output = Vector2;
    fn neg(self) -> Self::Output {
        Vector2::new(-self.x, -self.y)
    }
}


// come from
impl From<(f64,f64)> for Vector2 {
    fn from((x,y): (f64,f64)) -> Self {
        Vector2::new(x,y)
    }
}
impl From<[f64;2]> for Vector2 {
    fn from(a: [f64;2]) -> Self {
        Vector2::new(a[0],a[1])
    }
}

// goto
impl Into<(f64,f64)> for Vector2 {
    fn into(self) -> (f64,f64) {
        (self.x,self.y)
    }
}
impl Into<[f64;2]> for Vector2 {
    fn into(self) -> [f64;2] {
        [self.x, self.y]
    }
}


// fuck you neb, i dont care if this isnt how math works

// add
impl Add<f64> for Vector2 {
    type Output = Vector2;
    fn add(self, rhs: f64) -> Self::Output {
        Vector2::new(self.x + rhs, self.y + rhs)
    }
}
impl Add<Vector2> for Vector2 {
    type Output = Vector2;
    fn add(self, rhs: Vector2) -> Self::Output {
        Vector2::new(self.x + rhs.x, self.y + rhs.y)
    }
}
impl AddAssign<f64> for Vector2 {
    fn add_assign(&mut self, rhs: f64) {
        *self = *self + rhs;
    }
}
impl AddAssign<Vector2> for Vector2 {
    fn add_assign(&mut self, rhs: Vector2) {
        *self = *self + rhs;
    }
}

// sub
impl Sub<f64> for Vector2 {
    type Output = Vector2;
    fn sub(self, rhs: f64) -> Self::Output {
        self + -rhs
    }
}
impl Sub<Vector2> for Vector2 {
    type Output = Vector2;
    fn sub(self, rhs: Vector2) -> Self::Output {
        self + -rhs
    }
}
impl SubAssign<f64> for Vector2 {
    fn sub_assign(&mut self, rhs: f64) {
        *self = *self - rhs;
    }
}
impl SubAssign<Vector2> for Vector2 {
    fn sub_assign(&mut self, rhs: Vector2) {
        *self = *self - rhs;
    }
}

// mul
impl Mul<f64> for Vector2 {
    type Output = Vector2;
    fn mul(self, rhs: f64) -> Self::Output {
        Vector2::new(self.x * rhs, self.y * rhs)
    }
}
impl Mul<Vector2> for Vector2 {
    type Output = Vector2;
    fn mul(self, rhs: Vector2) -> Self::Output {
        Vector2::new(self.x * rhs.x, self.y * rhs.y)
    }
}
impl MulAssign<f64> for Vector2 {
    fn mul_assign(&mut self, rhs: f64) {
        *self = *self * rhs;
    }
}
impl MulAssign<Vector2> for Vector2 {
    fn mul_assign(&mut self, rhs: Vector2) {
        *self = *self * rhs;
    }
}

// div
impl Div<f64> for Vector2 {
    type Output = Vector2;
    fn div(self, rhs: f64) -> Self::Output {
        Vector2::new(self.x / rhs, self.y / rhs)
    }
}
impl Div<Vector2> for Vector2 {
    type Output = Vector2;
    fn div(self, rhs: Vector2) -> Self::Output {
        Vector2::new(self.x / rhs.x, self.y / rhs.y)
    }
}
impl DivAssign<f64> for Vector2 {
    fn div_assign(&mut self, rhs: f64) {
        *self = *self / rhs;
    }
}
impl DivAssign<Vector2> for Vector2 {
    fn div_assign(&mut self, rhs: Vector2) {
        *self = *self / rhs;
    }
}

// rem (mod)
impl Rem<f64> for Vector2 {
    type Output = Vector2;
    fn rem(self, rhs: f64) -> Self::Output {
        Vector2::new(self.x % rhs, self.y % rhs)
    }
}
impl Rem<Vector2> for Vector2 {
    type Output = Vector2;
    fn rem(self, rhs: Vector2) -> Self::Output {
        Vector2::new(self.x % rhs.x, self.y % rhs.y)
    }
}
impl RemAssign<f64> for Vector2 {
    fn rem_assign(&mut self, rhs: f64) {
        *self = *self % rhs;
    }
}
impl RemAssign<Vector2> for Vector2 {
    fn rem_assign(&mut self, rhs: Vector2) {
        *self = *self % rhs;
    }
}
